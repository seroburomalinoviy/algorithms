Привет, Студент!

1. Архитектура кода
1) Вижу правильный подход по памяти в том, чтобы использовать вложенные вызовы функций.
"""
load(transform(*extract()))
"""
Такой вызов лучше, чем использование промежуточных переменных, используемых по одному разу.

При этом в функции extract() извлекаются все данные из базы (использование метода fetchall()), что является не эффективным
 подходом по памяти.
Для решения этой проблемы можно использовать генераторы внутри функций и метод fetchone()
Пример реализации etl процесса с построчным извлечением данных из бд и применением генераторов можно посмотреть в статье
на Хабр:
https://habr.com/ru/articles/710106/

2. Оформление кода
Функция extract возвращает разнородные данные, в данном случае аннотация крайне важна для читаемости кода.
Я бы предложил написать так:
"""
def extract() -> tuple[dict[str, Any], dict[str, Any], list[tuple]]:
"""
Функция transform принимает на вход несколько аргументов, при этом важно и здесь указать тип передаваемых аргументов, -
это не только повысит читаемость кода, но и поможет избежать ошибок при доработке/рефакторинге кода в будущем.
Подробно про аннотации можно прочитать в документации Python: https://peps.python.org/pep-0484/.

Также важно учитывать правила наименования переменных в Python.
Двойное подчеркивание в начале переменной используется для того, чтобы показать, что переменная является приватной переменной класса.
Такая переменная будет недоступна вне класса для обращения привычным способом.
Хоть данное правило и является факультативным - интерпретатор Python не будет выдавать ошибки, если использовать такое именование
 внутри функции - соблюдать его предписывает документация Python.
https://peps.python.org/pep-0008/#method-names-and-instance-variables
Я бы предложил следующий вариант
"""
def transform(actors: dict[str, Any], writers: dict[str, Any], raw_data: list[tuple]):
"""

Здорово, что используешь dockstring при написании функций. Также лучше добавлять
 хотя бы краткое описание во всю свю документацию, как сделано в функции extract().

4. Запрос к бд
В исходных данных есть столбец содержащий списки json-ов, который не получится обработать sql запросами.
Поэтому я бы предложил разбить задачу на две части:
    1) Извлечь все возможные данные с помощью sql
        select id, imdb_rating, genre, title, plot, director,
        (
            select GROUP_CONCAT(actrs.name) from
            (
            (
            select * from actors
            ) as acs join
            (
                select actor_id
                from movie_actors
                where movie_id = movies.id
            ) as movie_acs
            on
            movie_acs.actor_id=acs.id
            ) as actrs
        )
        from movies
    2) Извлечь одной таблицей: movies.writers (тут у нас списки json), movies.id, movies.writer, writers.id, writers.name;
Далее мы могли бы заполнить индекс всеми данными из первого запроса, затем заполнить данными из второго
Таким образом, мы сократили количество запросов к бд до двух, один из которых взял на себя работы сопоставления имен
 актеров, что повысит общую скорость работы скрипта.





