"""
Задача:
Проверить, является длинное число (до 5000 знаков) числом Фибоначчи
"""

"""
Первая мысль - посчитать все числа Фибоначчи до 10**5000, сохранить в
памяти и делать проверку входного значения.

Долго и дорого по памяти.

Включаем прикидку == вероятностый алгоритм

прикиним сколько чисел фибоначи надо посчитать
числа фибоначчи растут примерно как 2**n
10 ~ 2**3 округлим в большую сторону, чтобы учесть все числа фибоначчи
тогда 10 ~ 2**4
тогда число с количеством цифр 10**5000  это число фибоначчи
примерно равное 2**20000
10**5000 <= 2**20000

Предположим нам нужно первые 40_000 чисел фибоначчи

хранить  40_000 чисел по 5000 десятичных знаков в каждом затратно по памяти 
тогда предположим что хвост числа (например последние 9 чисел) будет уникальным и не повторится в нашей 
последовательности из 40_000 чисел. тогда мы можем хранить этот хвост или модуль числа в множестве.

При этом вероятность того что модуль числа будет уникален не так уж высока, поэтому будем брать например 3 хвоста,
то ест считать три модуля от числа и хранить в трех множествах. 

"""

import random


def generate_fibs(mods):
    last_num_fib = 40_000
    lst_st = []
    # создадим множества
    for _ in mods:
        lst_st.append(set())

    # создадим числа фибоначчи
    for ind, p in enumerate(mods):
        f1 = 1
        f2 = 1
        lst_st[ind].add(1)
        for i in range(last_num_fib):
            f1, f2 = f2, (f1 + f2) % p
            lst_st[ind].add(f2)

    return lst_st


def check_fib(num, fibs, mods) -> bool:
    isfib = True
    for ind, p in enumerate(mods):
        isfib = isfib and num % p in fibs[ind]

    return isfib


mods = [10 ** 9 + 12, 10 ** 9 + 17, 10 ** 9 + 18]
fibs = generate_fibs(mods)
print(check_fib(354224848179261915075, fibs, mods))

